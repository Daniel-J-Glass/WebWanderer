from flask import Flask, send_file, redirect, make_response, session, render_template_string, request, stream_with_context, Response, render_template

import urllib

import time, os
from ProceduralSite import ProceduralSite
import secrets, uuid

from random_word import RandomWords

app = Flask(__name__)
app.secret_key = secrets.token_hex(16)

@app.route('/')
def start():
    layout = f"A large title named \"WebWanderer\". A \"Start\" button that redirects you.\n\
            Text that says \"Disclaimer: Everything, including this, is procedurally generated by GPT3.5 and Stable Diffusion. You control your own destiny.\"\n\
            A button for Daniel Glass' Github that links to this URL: \"https://github.com/Daniel-J-Glass\" and opens it in a new tab.\n\
            It is a short website."
    visuals="The style should be early 2000s retro. It should have a nice color scheme."
    name = "WebWanderer"

    # Generate 3 random words as a seed for the website
    r = RandomWords()
    words = [r.get_random_word() for i in range(3)]
    print(words)
    website_description = f"This is the title screen for a procedurally generated \"internet\" game named WebWanderer.\n\
        It should have:\n\
        a large title \"WebWanderer\",\n\
        a \"Start\" button for a website (the website is described in the button's title) that is loosely inspired by all of these words: {', '.join(words)},\n\
        The following shows how to extrapolate the random website's purpose:\n\
            Example 1: words: succinct, flowering, death\nwebsite='This is a website that is short that contains a gallery of flowers planted in skulls'\n\
            Example 2: words: heavenly, carwheel, yarn\n<website='This is a website with angelic themes that is a forum about knitting car tires'\n\
            Example 3: words: plastic, eternity, happiness\n<website='This is a website simulating a biography about a neohuman living in an eternal kingdom made from plastic bottles from the forgotten past'\n\
        a Github button for Daniel Glass (opening this URL: \"https://github.com/Daniel-J-Glass\" in a new tab)\n\
        a disclaimer about this experience being fully generated by GPT3.5\n\
        the website theme should be dark and mysterious with an early internet feel."

    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        website = ProceduralSite(purpose=website_description)
        website.generate_site()
        website.generate_assets()
        return send_file(website.html_filename)
    else:
        with open(os.path.join(app.template_folder,"loadingStart.html")) as f:
            loading_page = f.read()
        return render_template_string(loading_page)
    
    # return send_file(website.html_filename)


#TODO: Build capability for adding http://127.0.0.1:8080/next_page?search=jk&category=software&date=this-week to context
# http://127.0.0.1:8080/loading?parent_purpose=%3A+This+is+the+title+screen+for+a+procedurally+generated+%22internet%22+game+named+WebWanderer.&parent_uuid=17d3481e&button_context=%0D%0AClicked+button%3A+This+is+a+website+that+features+a+gallery+of+myelitides+and+chlorophane+patterns+with+a+forum+dedicated+to+McPhail+family+history
@app.route('/next_page')
def next_page():
    '''
    pass in parent UUID
    pass in unique button identifier (maybe)
    inside procedural site:
        pull parent where uuid = parent_uuid
        pull parent.purpose
        generate child with button, context, and parent (uuid and purpose)
            generate chid pushes new site record of:
                parent_uuid
                children/buttons = []
                name
                purpose
                html
                images
            self.uuid = push(child)

        push parent.children.append(child_uuid)

        find where button 
        modify parent HTML to have button reference child
        
    '''
    #decrypt the request args  

    parent_purpose = request.args.get('parent_purpose', '')
    parent_uuid = request.args.get('parent_uuid', '')
    button_context = request.args.get('button_context', '')
    
    #The previous website is relatively unimportant, but this is it:\n{parent_purpose}\n
    purpose = f"The previous website was {parent_purpose}. The following is the next website with the new purpose from this context:\n\
                 {button_context}\n\
                 The following is how the new website description should be extrapolated. They are only for reference:\n\
                 Example 1:\n\
                    old website = This is a website for buying and selling spoons\n\
                    clicked button = This is a website for purchasing a silver spoon owned by napoleon\n\
                    new purpose = This is the product page for purchasing one silver spoon that was owned by napoleon.\n\
                 Example 2:\n\
                    old purpose = This is a website for exploring the unique futuristic vacation planet Xarclan B.\n\
                    clicked button = This is a website about Xarclan B's unique habitat\n\
                    new purpose = This is a website that goes into detail about Xarclan B's biosphere and how it is unique.\n\
                 "
    
    def generate():
        yield f"Starting website generation ...\n"
        website = ProceduralSite(name="",visuals="",layout="",purpose = purpose)

        time_start = time.time()
        website.generate_site()
        time_site = time.time() - time_start

        yield f"Generated site in {time_site:.2f} seconds\n"
        time_start = time.time()
        website.generate_assets()
        time_assets = time.time()-time_start

        yield f"Generated assets in {time_assets:.2f} seconds\n"

        # Send the generated HTML file URL as the final event
        generated_file_url = f"/generated_site/{urllib.parse.quote(website.html_filename)}"
        yield f"{generated_file_url}"

    if 'text/event-stream' in request.accept_mimetypes:
        print("DAS")
        return Response(stream_with_context(generate()), mimetype='text/event-stream')
    else:
        return send_file(os.path.join(app.template_folder, "loadingNew.html"))

@app.route('/generated_site/<path:filename>')
def generated_site(filename):
    file_path = os.path.join(app.template_folder, filename)
    print(file_path)
    return send_file(file_path)

@app.before_request
def set_session_dir():
    if 'session_id' not in session:
        session['session_id'] = str(uuid.uuid4()) # generate a unique ID for the session
    session_dir = os.path.join('/tmp', session['session_id'])
    if not os.path.exists(session_dir):
        os.makedirs(session_dir)
    static_path = os.path.join(session_dir,"static")
    app.static_folder = static_path
    if not os.path.exists(static_path):
        os.makedirs(static_path)
    template_path = os.path.join(session_dir,"template")
    if not os.path.exists(template_path):
        app.template_folder = template_path

@app.after_request
def clear_session_files(response):
    if session.get('session_id'):
        session_id = session['session_id']
        session_dir = os.path.join('/tmp', session_id)
        if os.path.exists(session_dir):
            for filename in os.listdir(session_dir):
                file_path = os.path.join(session_dir, filename)
                os.remove(file_path)
            os.rmdir(session_dir)
    return response

@app.after_request
def add_header(response):
    if 'Cache-Control' not in response.headers:
        response.headers['Cache-Control'] = 'no-store'
    return response