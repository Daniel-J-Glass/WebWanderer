from flask import Flask, send_file, redirect, make_response, session, render_template_string, request, stream_with_context, Response, render_template, Blueprint
#import jsonify 
from flask import jsonify, current_app, copy_current_request_context, g
import urllib

import time, os
from ProceduralSite import ProceduralSite
import secrets, uuid
from threading import Thread

from random_word import RandomWords

#defining current app context for fucntion
app = Flask(__name__)
app.secret_key = secrets.token_hex(16)

@app.route('/',methods=['GET'])
def start():
    # redirecting to next_page
    return redirect('/next_page')

# route for starting site generation
@app.route('/generating')
def generate_site():
    def generate(purpose):
        website = ProceduralSite(purpose=purpose)
        for message in website.generate_site():
            if "Completed website generation" in message:
                for message in website.generate_assets():
                    yield f"data: {message}\n\n"
            else:
                yield f"data: {message}\n\n"

        time.sleep(2)
        
        yield f"data: {website.html_filename}\n\n"

    # Call the generate() function and stream the response to the client
    return Response(stream_with_context(generate(request.args.get('purpose'))),
                    mimetype='text/event-stream')


@app.route('/next_page')
def next_page():
    '''
    pass in parent UUID
    pass in unique button identifier (maybe)
    inside procedural site:
        pull parent where uuid = parent_uuid
        pull parent.purpose
        generate child with button, context, and parent (uuid and purpose)
            generate chid pushes new site record of:
                parent_uuid
                children/buttons = []
                name
                purpose
                html
                images
            self.uuid = push(child)

        push parent.children.append(child_uuid)

        find where button 
        modify parent HTML to have button reference child
        
    '''
    parent_purpose = request.args.get('parent_purpose', '')
    parent_uuid = request.args.get('parent_uuid', '')
    button_context = request.args.get('button_context', '')

    if not parent_purpose or not parent_uuid or not button_context:
        # Generate 3 random words as a seed for the website
        r = RandomWords()
        words = [r.get_random_word() for i in range(3)]
        print(words)
        purpose = f"This is the title screen for a procedurally generated \"internet\" game named WebWanderer.\n\
            It should have:\n\
            1 large title \"WebWanderer\",\n\
            A background that is a dark and mysterious room with a lit up computer screen that is a portal to another dimension.\n\
            1 clickable \"Start\" button for a website (the website is described in the button's title, not its text) that is loosely related to these words: {', '.join(words)},\n\
            The following shows how to generate the random website's purpose with the words. Do not explicitly use the words, instead generate a unique and exciting website concept from the combination of them:\n\
                Example 1: words: succinct, flowering, death\nwebsite='This is a website that is short that contains a gallery of flowers planted in skulls'\n\
                Example 2: words: heavenly, carwheel, yarn\n<website='This is a website with angelic themes that is a blog about knitting car tires'\n\
                Example 3: words: plastic, eternity, happiness\n<website='This is a website simulating a biography about a neohuman living in an eternal kingdom made from plastic bottles from the forgotten past'\n\
            1 medium-sized Github button in the top right that opens this URL: \"https://github.com/Daniel-J-Glass\" in a new tab\n\
            a disclaimer about this experience being fully generated by GPT3.5\n\
            the website theme should be dark and mysterious with an early internet feel."
    else:
        purpose = f"The previous website was {parent_purpose}. The following is the next website with the new purpose from this context:\n\
            {button_context}\n\
            The following is how the new website description should be extrapolated. Do not use these examples, instead use them to learn the website generation pattern.\n\
            Example 1:\n\
            old website = This is a website for buying and selling spoons\n\
            clicked button = This is a website for purchasing a silver spoon owned by napoleon\n\
            generated purpose = This is the product page for purchasing one silver spoon that was owned by napoleon\n\
            Example 2:\n\
            old purpose = This is a website for exploring the unique futuristic vacation planet Xarclan B\n\
            clicked button = This is a website about Xarclan B's unique habitat\n\
            generated purpose = This is a website that goes into detail about Xarclan B's biosphere and how it is unique\n\
            Example 3:\n\
            old purpose = This is a website for placing bets on medeival jousting\n\
            clicked button = This is a website about how you can contact us\n\
            generated purpose = This is a website that gives you the address and phone number for contacting the knight's guild"

    # streaming the generate function to the loading page
    # url encode the purpose so it can be passed as a query parameter
    purpose = urllib.parse.quote(purpose)
    return render_template('loadingPage.html', purpose=purpose)


@app.route('/new_site')
def new_site():
    html_filename = request.args.get('html', '')
    print("HTML FILENAME: ", html_filename)
    if html_filename:
        # Perform necessary actions here, such as sending the file or rendering the template
        file = os.path.abspath(os.path.join(app.template_folder, html_filename))
        # joining template path
        return send_file(file)
    else:
        return redirect('/')

@app.after_request
def add_header(response):
    if 'Cache-Control' not in response.headers:
        response.headers['Cache-Control'] = 'no-store'
    return response